# LoMorph
Morphological classification code for the LoTSS LOFAR survey.

Please refer to Mingo et al. 2019 (MNRAS 488 2701) and the attached flowchart for more details.

PLEASE NOTE: this code has been written for Python 2.7, for compatibility with some of the existing LOFAR framework. It will eventually be updated to Python 3. There are plans to add further functionalities as the surveys progress.

This code has been designed and tested to work with the LOFAR survey data, and it relies on cutouts and noise-filtered numpy arrays currently being generated by Dr Judith Croston. However, the algorithm is very simple, and it should be possible to adapt it to suit other radio surveys. 

Comments and suggestions to improve the code are very welcome. Please let me know if anything is unclear, or if you wish to use the code for a different survey and wish to know the reasoning behind how LoMorph was designed - the noise and resolution of the data played a key role in some of the decisions.

**KEY DEPENDENCIES**
Python 2.7
numpy, astropy, math, matplotlib, pyregion, skimage.measure (specifically, the label routine - http://scikit-image.org/docs/dev/api/skimage.measure.html#skimage.measure.label )

**FUNCTIONS**
The individual functions are briefly described and commented within the code. In summary:

*flood_mask* - flood-filling and masking function. 

Occasionally the ellipse regions created by the LOFAR source-finding algorithm (PyBDSF - https://github.com/lofar-astron/PyBDSF ) do not fully encompass the source emission, particularly as their centroid positions are flux-weighted. By flood-filling and carefully masking the data we can get a more accurate measurement of the flux and size of the source.

This function uses the LOFAR components catalogue to mask in/out individual components as ds9 regions.

*maxdist* - calculates the maximum distance from the optical ID to the end of the source (masking is applied so this is done individually for both sides).

*length* - calculates the full length of the source.

*wedge* - used to mask in/out each side of the source, so the peak and distnce finding can be carried out separately.

**FLOW**
Please see the enclosed flowchart for details.

The intial steps in the code carry out flood-filling and trim the original cutout to eliminate empty space around the source. 

The code starts from the optical host position and looks for the brightest cluster of sources in the source array. The flux is averaged over 4 groups of 2 pixels in a "+" pattern to dilute any image effects, as the pixel size is smaller than the beam size. The total flux and number of pixels is also calculated at this stage, to discard sources that do not meet the minimum flux and size criteria. This is necessary, since the catalogued fluxes and sizes are not noise-filtered or flood-filled, while our arrays are.

After the first peak (d1) is found, the code checks whether it corresponds to emission near the core of the source (in which case we already know it's an FRI and can pre-classify it), or whether it is so close that the structures are not clearly resolved - in the latter case the source is classified as unresolved and no further calculations are carried out. 

For core-bright FRIs the flow is restarted with the core masked out, so the next-brightest cluster of pixels can be found. 

A line is drawn between the first peak and the host position, and a 120 degree wedge is drawn along that axis to calculate the maximum extent of the source in that direction (distmax1) - the rest of the array is masked out. The wedge aperture has been optimised to avoid issues with most bent sources, and it is slightly larger for core-bright FRI.

The code then masks out the wedge and masks back in the rest of the source (excluding a circle of pixels around the position of the host), and finds the peak and maximum distance on the other side of the source (d2, distmax2).

The position angle differences between both sides are recorded, to obtain a measure of the "bendiness" of the source.

The classification is then carried out for sources that have not yet been classified in one of the previous steps. If the peaks of emission are closer to the core than to the edges of the source, it is classified as an FRI; if they are closer to the edges than to the core, the source is classified as an FRII. If the classification is different on both sides, the source is classified as a "hybrid" candidate. 

There is a further size check here to obtain the cleanest possible sample. Sources that are smaller than these criteria are technically resolved, but the structures are so close together that their classifications will be less reliable. These sources are put in the "small" categories.

The final steps are to create some plots to visualise the results of the classification, and an output table.
